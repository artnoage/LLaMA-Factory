import numpy as np
import random
from color_map import COLOR_MAP
from relationships import get_random_relationship

def generate_grid(name, existing_grids, min_width=3, max_width=20, min_height=3, max_height=20):
    width = random.randint(min_width, max_width)
    height = random.randint(min_height, max_height)
    tile_size = random.randint(20, 50)
    
    colors = list(COLOR_MAP.keys())
    
    # Initialize base weights
    base_weight = {c: 1 for c in colors}
    base_weight['Empty'] = 10  # Much higher base weight for empty tiles
    beta = 4  # Influence of neighboring colors
    
    # Initialize grid
    grid = np.full((height, width), None, dtype=object)
    
    for i in range(height):
        for j in range(width):
            # Initialize weights with base weights
            weight = {c: base_weight[c] for c in colors}
            
            # Collect neighboring colors
            neighbors = []
            if i > 0 and j > 0:
                neighbors.append(grid[i-1, j-1])
            if i > 0:
                neighbors.append(grid[i-1, j])
            if i > 0 and j < width -1:
                neighbors.append(grid[i-1, j+1])
            if j > 0:
                neighbors.append(grid[i, j-1])
            
            # Update weights based on neighboring colors
            for neighbor_color in neighbors:
                if neighbor_color is not None:
                    weight[neighbor_color] += beta
            
            # Convert weights to probabilities
            total_weight = sum(weight.values())
            probabilities = [weight[c] / total_weight for c in colors]
            
            # Select color
            grid[i, j] = np.random.choice(colors, p=probabilities)
    
    # Decide whether to apply a relationship
    if existing_grids and random.random() < 0.5:  # 50% chance if there are existing grids
        reference_grid = random.choice(existing_grids)
        relationship = get_random_relationship()
        new_grid = relationship.apply(np.copy(reference_grid['array']))
        relational_name = f"{name}_relational"
        tag = f"generated by grid {reference_grid['name']} using relationship {relationship.__class__.__name__} with extra parameters {relationship.extra_params}"
        return {
            'name': relational_name,
            'width': reference_grid['width'],
            'height': reference_grid['height'],
            'tile_size': reference_grid['tile_size'],
            'array': new_grid,
            'tag': tag
        }
    else:
        tag = "random grid"
    
    return {
        'name': name,
        'width': width,
        'height': height,
        'tile_size': tile_size,
        'array': grid,
        'tag': tag
    }

def place_grids(grids, margin):
    placed_grids = []
    extra_margin = 10  # Reduced additional margin between grids
    max_attempts = 1000  # Increased maximum attempts
    canvas_size = [500, 500]  # Initial canvas size

    while True:
        # Sort grids by area (largest first)
        grids.sort(key=lambda g: g['width'] * g['height'], reverse=True)

        placed_grids = []
        for grid in grids:
            grid_width = grid['width'] * grid['tile_size']
            grid_height = grid['height'] * grid['tile_size']
            
            for _ in range(max_attempts):
                x = random.randint(margin, canvas_size[0] - grid_width - margin)
                y = random.randint(margin, canvas_size[1] - grid_height - margin)
                
                # Check if this position overlaps with any previously placed grid
                overlap = any(
                    rect_overlap(
                        (x - extra_margin, y - extra_margin, 
                         x + grid_width + extra_margin, y + grid_height + extra_margin),
                        (pg['position'][0] - extra_margin, pg['position'][1] - extra_margin, 
                         pg['position'][0] + pg['width'] * pg['tile_size'] + extra_margin,
                         pg['position'][1] + pg['height'] * pg['tile_size'] + extra_margin)
                    )
                    for pg in placed_grids
                )
                
                if not overlap:
                    grid['position'] = (x, y)
                    placed_grids.append(grid)
                    break
            else:
                # If we couldn't place this grid, increase canvas size and try again
                canvas_size = [int(size * 1.1) for size in canvas_size]
                break
        else:
            # All grids placed successfully
            break

    # Rescale positions to fit 1000x1000 canvas
    scale_x = 1000 / canvas_size[0]
    scale_y = 1000 / canvas_size[1]
    for grid in placed_grids:
        x, y = grid['position']
        grid['position'] = (int(x * scale_x), int(y * scale_y))
        grid['tile_size'] = int(grid['tile_size'] * min(scale_x, scale_y))

    return placed_grids

def rect_overlap(rect1, rect2):
    return not (rect1[2] <= rect2[0] or rect1[0] >= rect2[2] or
                rect1[3] <= rect2[1] or rect1[1] >= rect2[3])
